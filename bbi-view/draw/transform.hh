#ifndef DPJ_TRANSFORM_HH_
#define DPJ_TRANSFORM_HH_

#include <array>

namespace dpj
{
  namespace gl
  {
    struct transform
    {
      std::array<std::array<float, 4>, 4> m
      {{
        {1, 0, 0, 0},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {0, 0, 0, 1}
      }};
      
      friend
      transform operator*(transform a, transform b)
      {
        transform r;
        r.m[0][0]=a.m[0][0]*b.m[0][0]+a.m[0][1]*b.m[1][0]+a.m[0][2]*b.m[2][0]+a.m[0][3]*b.m[3][0];
        r.m[0][1]=a.m[0][0]*b.m[0][1]+a.m[0][1]*b.m[1][1]+a.m[0][2]*b.m[2][1]+a.m[0][3]*b.m[3][1];
        r.m[0][2]=a.m[0][0]*b.m[0][2]+a.m[0][1]*b.m[1][2]+a.m[0][2]*b.m[2][2]+a.m[0][3]*b.m[3][2];
        r.m[0][3]=a.m[0][0]*b.m[0][3]+a.m[0][1]*b.m[1][3]+a.m[0][2]*b.m[2][3]+a.m[0][3]*b.m[3][3];
        r.m[1][0]=a.m[1][0]*b.m[0][0]+a.m[1][1]*b.m[1][0]+a.m[1][2]*b.m[2][0]+a.m[1][3]*b.m[3][0];
        r.m[1][1]=a.m[1][0]*b.m[0][1]+a.m[1][1]*b.m[1][1]+a.m[1][2]*b.m[2][1]+a.m[1][3]*b.m[3][1];
        r.m[1][2]=a.m[1][0]*b.m[0][2]+a.m[1][1]*b.m[1][2]+a.m[1][2]*b.m[2][2]+a.m[1][3]*b.m[3][2];
        r.m[1][3]=a.m[1][0]*b.m[0][3]+a.m[1][1]*b.m[1][3]+a.m[1][2]*b.m[2][3]+a.m[1][3]*b.m[3][3];
        r.m[2][0]=a.m[2][0]*b.m[0][0]+a.m[2][1]*b.m[1][0]+a.m[2][2]*b.m[2][0]+a.m[2][3]*b.m[3][0];
        r.m[2][1]=a.m[2][0]*b.m[0][1]+a.m[2][1]*b.m[1][1]+a.m[2][2]*b.m[2][1]+a.m[2][3]*b.m[3][1];
        r.m[2][2]=a.m[2][0]*b.m[0][2]+a.m[2][1]*b.m[1][2]+a.m[2][2]*b.m[2][2]+a.m[2][3]*b.m[3][2];
        r.m[2][3]=a.m[2][0]*b.m[0][3]+a.m[2][1]*b.m[1][3]+a.m[2][2]*b.m[2][3]+a.m[2][3]*b.m[3][3];
        r.m[3][0]=a.m[3][0]*b.m[0][0]+a.m[3][1]*b.m[1][0]+a.m[3][2]*b.m[2][0]+a.m[3][3]*b.m[3][0];
        r.m[3][1]=a.m[3][0]*b.m[0][1]+a.m[3][1]*b.m[1][1]+a.m[3][2]*b.m[2][1]+a.m[3][3]*b.m[3][1];
        r.m[3][2]=a.m[3][0]*b.m[0][2]+a.m[3][1]*b.m[1][2]+a.m[3][2]*b.m[2][2]+a.m[3][3]*b.m[3][2];
        r.m[3][3]=a.m[3][0]*b.m[0][3]+a.m[3][1]*b.m[1][3]+a.m[3][2]*b.m[2][3]+a.m[3][3]*b.m[3][3];
        
        return r;
      }
    };
  }
}
#endif /* DPJ_TRANSFORM_HH_ */
